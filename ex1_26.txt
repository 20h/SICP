(square (expmod base (/ exp 2) m))
를
(* (expmod base (/ exp 2) m)
   (expmod base (/ exp 2) m))
로 바꿔서 실행했더니 0(logN)이 아닌 0(N) 알고리즘이 되었다. 왜 그럴까?

combination을 평가할 때엔 모든 argument들을 먼저 evaluate하게 된다.
따라서 * 연산을 처리하기 전에 expmod가 두번 계산된다.

교과서에 제시된 expmod에서는 매 스텝마다 
문제의 크기 exp(=n)를 반으로 줄였기 때문에 0(logN) 알고리즘이었지만,
(100 => 50 => 25 => ... => 1)

Louis가 변경한 알고리즘은, 매 스텝마다 문제의 크기는 반으로 줄였지만 매번 문제 수를 두배로 만들어냈기 때문에, 전체적으론 문제의 크기를 줄이거나 늘리지 않는다. 따라서 0(N)의 성능을 가진다.
100 => 50+50 => 25+25+25+25 => ... 1+1+1+1+1+...(100개)

